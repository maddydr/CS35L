Following the React tic-tac-toe tutorial, I began with downloading Node.js.

Opened the files in VSCode and ran the npm install followed by npm start. After opening the files in VSCode, I learned how all the files interacted. It being my first time working with JavaScript and React, I learned how they all connected.

I worked on the Board() function first by just trying to get 9 squares to appear, then putting them in row and column form. To do this, one must know the <div> </div> JSX HTML syntax. Then, we worked on making the board interactive. First we add a square function that takes in a value – remember you must surround the value with {} to use the actual variable. Call this newly made square function in the Board function passing numbers 1-9 as values. Now, import useState and initialize variables value and setValue to useState(null). This effectively stores the state value in value and creates setValue, a function used to change value. Add a function handleClick() inside the Square() function that will call setValue(‘X’) when called.

We now work on creating a way to declare a winner with our games. To do this, according to the tutorial, it is recommended we refactor the ‘state’ component of the squares to the Board() function. We initialize the squares to null with const[squares, setSquares] = useState(Array(9).fill(null));. These state values in the array will be passed to the child function Square when called. Now to handle what happens when a square is clicked, we will pass the Square() function the necessary information to handle the state of the square. To do this, we add a function in Square called onSquareClick, as well as add it as a prop to Square. In Board, we connect the onSquareClick to call a function handleClick within Board. Define handleClick with a slice() of the squares array, setting nextSquares to the appropriate ‘X’ or ‘O’ based on the index of the click,, and updating setSquares. Calling setSquares triggers a re-render of components. Note that to pass the index i to handleClick, we can’t directly pass i in like <Square value={squares[0]} onSquareClick={handleClick(0)} />. This would directly call the handleClick function right there and it runs too early. Use the onSquareClick={() => handleClick(0)} /> syntax of saying once the square is clicked, then run the function. Do this for all 9 squares.

To add the component of taking turns, add a variable xIsNext along with setXIsNext using the useState(true) feature. In the handleClick function, first check if the square[i] already has a value, if it doesn't, check is xIsNext is true and if so, the square should be an ‘X’, otherwise an ‘O’. Now add the function calculateWinner (logic was given). Check if there was a winner at the same time we check if the square already has a value. Additionally, add a winner variable to hold the status of the call calculateWinner and an if statement checking if there is a winner, and displaying the correct text if so. 

Now to add the component of time travel. To do this, we will refactor again adding a Game component. We are lifting up the state component to the Game level. Move the xIsNext variable to Game() and add a history, setHistory variable assigning it with useState([Array(9).fill(null)]). We also add a variable currentSquares to hold the most recent history of moves. Create a handlePlay function inside Game to update the game. Pass Board xIsNext, currentSquares, and handlePlay. Remove the calls to useState in Game because it is now handled in Game, and instead add a single call to onPlay. In our Game function handlePlay, update the history by adding a new history array entry, was well as flipping the boolean xIsNext.

To display these pas moves, we will use the array map method. Use a map to transform the history into React elements. Add a history.ap((squares,move) => { … } with logic to display text ‘Go to move #’ if moves are > 0. Add the button components with the same => syntax. Make the move index as a key and add <li key={move}>. In handlePlay, update the history with a nextHistory variable to add the portion of history you want. Update currentMove to this latest history. Change the Game to render the selected move by adding currentSquares = history[currrentMove]. 

You now should have a running tic-tac-toe game with the history feature.
